/*********************************************************************************/
/*                                                                               */
/*  Copyright (C) 2024 Seif Kandil (k0T0z)                                       */
/*                                                                               */
/*  This file is a part of the ENIGMA Development Environment.                   */
/*                                                                               */
/*                                                                               */
/*  ENIGMA is free software: you can redistribute it and/or modify it under the  */
/*  terms of the GNU General Public License as published by the Free Software    */
/*  Foundation, version 3 of the license or any later version.                   */
/*                                                                               */
/*  This application and its source code is distributed AS-IS, WITHOUT ANY       */
/*  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS    */
/*  FOR A PARTICULAR PURPOSE. See the GNU General Public License for more        */
/*  details.                                                                     */
/*                                                                               */
/*  You should have recieved a copy of the GNU General Public License along      */
/*  with this code. If not, see <http://www.gnu.org/licenses/>                   */
/*                                                                               */
/*  ENIGMA is an environment designed to create games and other programs with a  */
/*  high-level, fully compilable language. Developers of ENIGMA or anything      */
/*  associated with ENIGMA are in no way responsible for its users or            */
/*  applications created by its users, or damages caused by the environment      */
/*  or programs made in the environment.                                         */
/*                                                                               */
/*********************************************************************************/

syntax = "proto3";
package gui.model.schema;

import "google/protobuf/descriptor.proto";

extend google.protobuf.EnumValueOptions {
    optional string eo_id_start = 70000;
    optional string value_caption = 70001;
    optional VisualShaderNodePortType value_port_type = 70002;
    optional string value_name = 70003;
}

// https://protobuf.dev/programming-guides/proto3/#enum-default
enum VisualShaderNodePortType {
    PORT_TYPE_UNSPECIFIED = 0;
    PORT_TYPE_SCALAR = 1;
    PORT_TYPE_SCALAR_INT = 2;
    PORT_TYPE_SCALAR_UINT = 3;
    PORT_TYPE_VECTOR_2D = 4;
    PORT_TYPE_VECTOR_3D = 5;
    PORT_TYPE_VECTOR_4D = 6;
    PORT_TYPE_BOOLEAN = 7;
};

enum VisualShaderNodeCategory {
    CATEGORY_UNSPECIFIED = 0;
    CATEGORY_INPUT = 1;
    CATEGORY_OUTPUT = 2;
    CATEGORY_SCALAR = 3;
    CATEGORY_VECTOR = 4;
    CATEGORY_COLOR = 5;
    CATEGORY_CONDITIONAL = 6;
    CATEGORY_UTILITY = 7;
};

enum VisualShaderNodeVectorType {
    TYPE_VECTOR_UNSPECIFIED = 0 [(value_caption) = "UNSPECIFIED", (value_port_type) = PORT_TYPE_UNSPECIFIED];
    TYPE_VECTOR_2D = 1 [(value_caption) = "Vector2D", (value_port_type) = PORT_TYPE_VECTOR_2D];
    TYPE_VECTOR_3D = 2 [(value_caption) = "Vector3D", (value_port_type) = PORT_TYPE_VECTOR_3D];
    TYPE_VECTOR_4D = 3 [(value_caption) = "Vector4D", (value_port_type) = PORT_TYPE_VECTOR_4D];
};

// See:
// https://protobuf.dev/programming-guides/extension_declarations/
// https://protobuf.dev/programming-guides/proto2/#extensions
// https://protobuf.dev/programming-guides/proto3/#options
// https://protobuf.dev/programming-guides/proto3/#customoptions
// https://protobuf.dev/reference/protobuf/proto3-spec/#option
extend google.protobuf.MessageOptions {
    optional int32 mo_id_start = 60000;
    string node_caption = 60001;

    int32 node_input_port_count = 60002;
    repeated string node_input_port_caption = 60003;
    repeated VisualShaderNodePortType node_input_port_type = 60004;

    int32 node_output_port_count = 60005;
    repeated string node_output_port_caption = 60006;
    repeated VisualShaderNodePortType node_output_port_type = 60007;

    string node_category_path = 60008;
    VisualShaderNodeCategory node_category = 60009;

    string node_description = 60010;
}

/*************************************/
/* Input Node                        */
/*************************************/

enum VisualShaderNodeInputType {
    INPUT_TYPE_UNSPECIFIED = 0 [
        (value_caption) = "NONE", 
        (value_name) = "", 
        (value_port_type) = PORT_TYPE_UNSPECIFIED];
    INPUT_TYPE_UV = 1 [
        (value_caption) = "UV", 
        (value_name) = "FragCoord", 
        (value_port_type) = PORT_TYPE_VECTOR_2D];
    INPUT_TYPE_TIME = 2 [
        (value_caption) = "Time", 
        (value_name) = "uTime", 
        (value_port_type) = PORT_TYPE_SCALAR];
};

message VisualShaderNodeInput {
    option (node_caption) = "Input";
    option (node_input_port_count) = 0;
    
    option (node_output_port_count) = 1;
    option (node_output_port_caption) = "";
    option (node_output_port_type) = PORT_TYPE_UNSPECIFIED;

    option (node_category_path) = "Input";
    option (node_category) = CATEGORY_INPUT;

    option (node_description) = "Input node that can be used to pass a value into the shader.";

    optional VisualShaderNodeInputType type = 1;
}

/*************************************/
/* Output Node                       */
/*************************************/

enum VisualShaderNodeOutputType {
    OUTPUT_TYPE_UNSPECIFIED = 0 [(value_name) = ""];
    OUTPUT_TYPE_COLOR = 1 [(value_name) = "FragColor"];
};

message VisualShaderNodeOutput {
    option (node_caption) = "Output";
    option (node_input_port_count) = 1;
    option (node_input_port_caption) = "Color";
    option (node_input_port_type) = PORT_TYPE_VECTOR_4D;
    
    option (node_output_port_count) = 0;

    option (node_category_path) = "";
    option (node_category) = CATEGORY_UNSPECIFIED;

    option (node_description) = "Output node can not be added/removed, it is always present in the shader graph.";
}

/*************************************/
/* CONSTANTS                         */
/*************************************/

message VisualShaderNodeFloatConstant {
    option (node_caption) = "FloatConstant";
    option (node_input_port_count) = 0;
    
    option (node_output_port_count) = 1;
    option (node_output_port_caption) = "";
    option (node_output_port_type) = PORT_TYPE_SCALAR;

    option (node_category) = CATEGORY_INPUT;
    option (node_category_path) = "Input";

    option (node_description) = "Scalar floating-point constant.";

    optional float value = 1;
}

message VisualShaderNodeIntConstant {
    option (node_caption) = "IntConstant";
    option (node_input_port_count) = 0;
    
    option (node_output_port_count) = 1;
    option (node_output_port_caption) = "";
    option (node_output_port_type) = PORT_TYPE_SCALAR_INT;

    option (node_category) = CATEGORY_INPUT;
    option (node_category_path) = "Input";

    option (node_description) = "Scalar integer constant.";

    optional int32 value = 1;
}

message VisualShaderNodeUIntConstant {
    option (node_caption) = "UIntConstant";
    option (node_input_port_count) = 0;
    
    option (node_output_port_count) = 1;
    option (node_output_port_caption) = "";
    option (node_output_port_type) = PORT_TYPE_SCALAR_UINT;

    option (node_category) = CATEGORY_INPUT;
    option (node_category_path) = "Input";

    option (node_description) = "Scalar unsigned integer constant.";

    optional uint32 value = 1;
}

message VisualShaderNodeBooleanConstant {
    option (node_caption) = "BooleanConstant";
    option (node_input_port_count) = 0;
    
    option (node_output_port_count) = 1;
    option (node_output_port_caption) = "";
    option (node_output_port_type) = PORT_TYPE_BOOLEAN;

    option (node_category) = CATEGORY_INPUT;
    option (node_category_path) = "Input";

    option (node_description) = "Scalar boolean constant.";

    optional bool value = 1;
}

message VisualShaderNodeColorConstant {
    option (node_caption) = "ColorConstant";
    option (node_input_port_count) = 0;
    
    option (node_output_port_count) = 1;
    option (node_output_port_caption) = "";
    option (node_output_port_type) = PORT_TYPE_VECTOR_4D;

    option (node_category) = CATEGORY_INPUT;
    option (node_category_path) = "Input";

    option (node_description) = "Vector color constant.";

    optional float r = 1;
    optional float g = 2;
    optional float b = 3;
    optional float a = 4;
}

message VisualShaderNodeVec2Constant {
    option (node_caption) = "Vec2Constant";
    option (node_input_port_count) = 0;
    
    option (node_output_port_count) = 1;
    option (node_output_port_caption) = "";
    option (node_output_port_type) = PORT_TYPE_VECTOR_2D;

    option (node_category) = CATEGORY_INPUT;
    option (node_category_path) = "Input";

    option (node_description) = "Vector 2D constant.";

    optional float x = 1;
    optional float y = 2;
}

message VisualShaderNodeVec3Constant {
    option (node_caption) = "Vec3Constant";
    option (node_input_port_count) = 0;
    
    option (node_output_port_count) = 1;
    option (node_output_port_caption) = "";
    option (node_output_port_type) = PORT_TYPE_VECTOR_3D;

    option (node_category) = CATEGORY_INPUT;
    option (node_category_path) = "Input";

    option (node_description) = "Vector 3D constant.";

    optional float x = 1;
    optional float y = 2;
    optional float z = 3;
}

message VisualShaderNodeVec4Constant {
    option (node_caption) = "Vec4Constant";
    option (node_input_port_count) = 0;
    
    option (node_output_port_count) = 1;
    option (node_output_port_caption) = "";
    option (node_output_port_type) = PORT_TYPE_VECTOR_4D;

    option (node_category) = CATEGORY_INPUT;
    option (node_category_path) = "Input";

    option (node_description) = "Vector 4D constant.";

    optional float x = 1;
    optional float y = 2;
    optional float z = 3;
    optional float w = 4;
}

/*************************************/
/* OPERATORS                         */
/*************************************/

message VisualShaderNodeFloatOp {
    option (node_caption) = "FloatOp";

    option (node_input_port_count) = 2;

    option (node_input_port_caption) = "p1";
    option (node_input_port_type) = PORT_TYPE_SCALAR;

    option (node_input_port_caption) = "p2";
    option (node_input_port_type) = PORT_TYPE_SCALAR;
    
    option (node_output_port_count) = 1;
    option (node_output_port_caption) = "op";
    option (node_output_port_type) = PORT_TYPE_SCALAR;

    option (node_category) = CATEGORY_SCALAR;
    option (node_category_path) = "Operators/Scalar";

    option (node_description) = "Scalar floating-point operator.";

    enum VisualShaderNodeFloatOpType {
        OP_UNSPECIFIED = 0 [(value_caption) = "UNSPECIFIED"];
        OP_ADD = 1 [(value_caption) = "Add"];
        OP_SUB = 2 [(value_caption) = "Subtract"];
        OP_MUL = 3 [(value_caption) = "Multiply"];
        OP_DIV = 4 [(value_caption) = "Divide"];
        OP_MOD = 5 [(value_caption) = "Modulo"];
        OP_POW = 6 [(value_caption) = "Power"];
        OP_MAX = 7 [(value_caption) = "Max"];
        OP_MIN = 8 [(value_caption) = "Min"];
        OP_ATAN2 = 9 [(value_caption) = "Atan2"];
        OP_STEP = 10 [(value_caption) = "Step"];
    };

    optional VisualShaderNodeFloatOpType op = 1;
}

message VisualShaderNodeIntOp {
    option (node_caption) = "IntOp";

    option (node_input_port_count) = 2;

    option (node_input_port_caption) = "p1";
    option (node_input_port_type) = PORT_TYPE_SCALAR_INT;

    option (node_input_port_caption) = "p2";
    option (node_input_port_type) = PORT_TYPE_SCALAR_INT;
    
    option (node_output_port_count) = 1;
    option (node_output_port_caption) = "op";
    option (node_output_port_type) = PORT_TYPE_SCALAR_INT;

    option (node_category) = CATEGORY_SCALAR;
    option (node_category_path) = "Operators/Scalar";

    option (node_description) = "Scalar integer operator.";

    enum VisualShaderNodeIntOpType {
        OP_UNSPECIFIED = 0 [(value_caption) = "UNSPECIFIED"];
        OP_ADD = 1 [(value_caption) = "Add"];
        OP_SUB = 2 [(value_caption) = "Subtract"];
        OP_MUL = 3 [(value_caption) = "Multiply"];
        OP_DIV = 4 [(value_caption) = "Divide"];
        OP_MOD = 5 [(value_caption) = "Modulo"];
        OP_MAX = 6 [(value_caption) = "Max"];
        OP_MIN = 7 [(value_caption) = "Min"];
        OP_BITWISE_AND = 8 [(value_caption) = "BitwiseAnd"];
        OP_BITWISE_OR = 9 [(value_caption) = "BitwiseOr"];
        OP_BITWISE_XOR = 10 [(value_caption) = "BitwiseXor"];
        OP_BITWISE_LEFT_SHIFT = 11 [(value_caption) = "BitwiseLeftShift"];
        OP_BITWISE_RIGHT_SHIFT = 12 [(value_caption) = "BitwiseRightShift"];
    };

    optional VisualShaderNodeIntOpType op = 1;
}

message VisualShaderNodeUIntOp {
    option (node_caption) = "UIntOp";

    option (node_input_port_count) = 2;

    option (node_input_port_caption) = "p1";
    option (node_input_port_type) = PORT_TYPE_SCALAR_UINT;

    option (node_input_port_caption) = "p2";
    option (node_input_port_type) = PORT_TYPE_SCALAR_UINT;
    
    option (node_output_port_count) = 1;
    option (node_output_port_caption) = "op";
    option (node_output_port_type) = PORT_TYPE_SCALAR_UINT;

    option (node_category) = CATEGORY_SCALAR;
    option (node_category_path) = "Operators/Scalar";

    option (node_description) = "Scalar unsigned integer operator.";

    enum VisualShaderNodeUIntOpType {
        OP_UNSPECIFIED = 0 [(value_caption) = "UNSPECIFIED"];
        OP_ADD = 1 [(value_caption) = "Add"];
        OP_SUB = 2 [(value_caption) = "Subtract"];
        OP_MUL = 3 [(value_caption) = "Multiply"];
        OP_DIV = 4 [(value_caption) = "Divide"];
        OP_MOD = 5 [(value_caption) = "Modulo"];
        OP_MAX = 6 [(value_caption) = "Max"];
        OP_MIN = 7 [(value_caption) = "Min"];
        OP_BITWISE_AND = 8 [(value_caption) = "BitwiseAnd"];
        OP_BITWISE_OR = 9 [(value_caption) = "BitwiseOr"];
        OP_BITWISE_XOR = 10 [(value_caption) = "BitwiseXor"];
        OP_BITWISE_LEFT_SHIFT = 11 [(value_caption) = "BitwiseLeftShift"];
        OP_BITWISE_RIGHT_SHIFT = 12 [(value_caption) = "BitwiseRightShift"];
    };

    optional VisualShaderNodeUIntOpType op = 1;
}

message VisualShaderNodeVectorOp {
    option (node_caption) = "VectorOp";

    option (node_input_port_count) = 2;

    option (node_input_port_caption) = "p1";
    option (node_input_port_type) = PORT_TYPE_UNSPECIFIED;

    option (node_input_port_caption) = "p2";
    option (node_input_port_type) = PORT_TYPE_UNSPECIFIED;
    
    option (node_output_port_count) = 1;

    option (node_output_port_caption) = "op";
    option (node_output_port_type) = PORT_TYPE_UNSPECIFIED;

    option (node_category) = CATEGORY_VECTOR;
    option (node_category_path) = "Operators/Vector";

    option (node_description) = "Vector operator.";

    enum VisualShaderNodeVectorOpType {
        OP_UNSPECIFIED = 0 [(value_caption) = "UNSPECIFIED"];
        OP_ADD = 1 [(value_caption) = "Add"];
        OP_SUB = 2 [(value_caption) = "Subtract"];
        OP_MUL = 3 [(value_caption) = "Multiply"];
        OP_DIV = 4 [(value_caption) = "Divide"];
        OP_MOD = 5 [(value_caption) = "Modulo"];
        OP_POW = 6 [(value_caption) = "Power"];
        OP_MAX = 7 [(value_caption) = "Max"];
        OP_MIN = 8 [(value_caption) = "Min"];
        OP_CROSS = 9 [(value_caption) = "Cross"];
        OP_ATAN2 = 10 [(value_caption) = "Atan2"];
        OP_REFLECT = 11 [(value_caption) = "Reflect"];
        OP_STEP = 12 [(value_caption) = "Step"];
    };

    optional VisualShaderNodeVectorType type = 1;
    optional VisualShaderNodeVectorOpType op = 2;
}

/*************************************/
/* Funcs Node                        */
/*************************************/

message VisualShaderNodeFloatFunc {
    option (node_caption) = "FloatFunc";

    option (node_input_port_count) = 1;

    option (node_input_port_caption) = "p";
    option (node_input_port_type) = PORT_TYPE_SCALAR;
    
    option (node_output_port_count) = 1;
    option (node_output_port_caption) = "func";
    option (node_output_port_type) = PORT_TYPE_SCALAR;

    option (node_category) = CATEGORY_SCALAR;
    option (node_category_path) = "Functions/Scalar";

    option (node_description) = "Scalar floating-point function.";

    enum VisualShaderNodeFloatFuncType {
        FUNC_UNSPECIFIED = 0 [(value_caption) = "UNSPECIFIED"];
        FUNC_SIN = 1 [(value_caption) = "Sin"];
        FUNC_COS = 2 [(value_caption) = "Cos"];
        FUNC_TAN = 3 [(value_caption) = "Tan"];
        FUNC_ASIN = 4 [(value_caption) = "Asin"];
        FUNC_ACOS = 5 [(value_caption) = "Acos"];
        FUNC_ATAN = 6 [(value_caption) = "Atan"];
        FUNC_SINH = 7 [(value_caption) = "Sinh"];
        FUNC_COSH = 8 [(value_caption) = "Cosh"];
        FUNC_TANH = 9 [(value_caption) = "Tanh"];
        FUNC_LOG = 10 [(value_caption) = "Log"];
        FUNC_EXP = 11 [(value_caption) = "Exp"];
        FUNC_SQRT = 12 [(value_caption) = "Sqrt"];
        FUNC_ABS = 13 [(value_caption) = "Abs"];
        FUNC_SIGN = 14 [(value_caption) = "Sign"];
        FUNC_FLOOR = 15 [(value_caption) = "Floor"];
        FUNC_ROUND = 16 [(value_caption) = "Round"];
        FUNC_CEIL = 17 [(value_caption) = "Ceil"];
        FUNC_FRACT = 18 [(value_caption) = "Fract"];
        FUNC_SATURATE = 19 [(value_caption) = "Saturate"];
        FUNC_NEGATE = 20 [(value_caption) = "Negate"];
        FUNC_ACOSH = 21 [(value_caption) = "Acosh"];
        FUNC_ASINH = 22 [(value_caption) = "Asinh"];
        FUNC_ATANH = 23 [(value_caption) = "Atanh"];
        FUNC_DEGREES = 24 [(value_caption) = "Degrees"];
        FUNC_EXP2 = 25 [(value_caption) = "Exp2"];
        FUNC_INVERSE_SQRT = 26 [(value_caption) = "InverseSqrt"];
        FUNC_LOG2 = 27 [(value_caption) = "Log2"];
        FUNC_RADIANS = 28 [(value_caption) = "Radians"];
        FUNC_RECIPROCAL = 29 [(value_caption) = "Reciprocal"];
        FUNC_ROUNDEVEN = 30 [(value_caption) = "RoundEven"];
        FUNC_TRUNC = 31 [(value_caption) = "Trunc"];
        FUNC_ONEMINUS = 32 [(value_caption) = "OneMinus"];
    };

    optional VisualShaderNodeFloatFuncType func = 1;
}

message VisualShaderNodeIntFunc {
    option (node_caption) = "IntFunc";

    option (node_input_port_count) = 1;

    option (node_input_port_caption) = "p";
    option (node_input_port_type) = PORT_TYPE_SCALAR_INT;
    
    option (node_output_port_count) = 1;
    option (node_output_port_caption) = "func";
    option (node_output_port_type) = PORT_TYPE_SCALAR_INT;

    option (node_category) = CATEGORY_SCALAR;
    option (node_category_path) = "Functions/Scalar";

    option (node_description) = "Scalar integer function.";

    enum VisualShaderNodeIntFuncType {
        FUNC_UNSPECIFIED = 0 [(value_caption) = "UNSPECIFIED"];
        FUNC_ABS = 1 [(value_caption) = "Abs"];
        FUNC_NEGATE = 2 [(value_caption) = "Negate"];
        FUNC_SIGN = 3 [(value_caption) = "Sign"];
        FUNC_BITWISE_NOT = 4 [(value_caption) = "BitwiseNot"];
    };

    optional VisualShaderNodeIntFuncType func = 1;
}

message VisualShaderNodeUIntFunc {
    option (node_caption) = "UIntFunc";

    option (node_input_port_count) = 1;

    option (node_input_port_caption) = "p";
    option (node_input_port_type) = PORT_TYPE_SCALAR_UINT;
    
    option (node_output_port_count) = 1;
    option (node_output_port_caption) = "func";
    option (node_output_port_type) = PORT_TYPE_SCALAR_UINT;

    option (node_category) = CATEGORY_SCALAR;
    option (node_category_path) = "Functions/Scalar";

    option (node_description) = "Scalar unsigned integer function.";

    enum VisualShaderNodeUIntFuncType {
        FUNC_UNSPECIFIED = 0 [(value_caption) = "UNSPECIFIED"];
        FUNC_NEGATE = 1 [(value_caption) = "Negate"];
        FUNC_BITWISE_NOT = 2 [(value_caption) = "BitwiseNot"];
    };

    optional VisualShaderNodeUIntFuncType func = 1;
}

message VisualShaderNodeVectorFunc {
    option (node_caption) = "VectorFunc";

    option (node_input_port_count) = 1;

    option (node_input_port_caption) = "p";
    option (node_input_port_type) = PORT_TYPE_UNSPECIFIED;
    
    option (node_output_port_count) = 1;
    option (node_output_port_caption) = "func";
    option (node_output_port_type) = PORT_TYPE_UNSPECIFIED;

    option (node_category) = CATEGORY_VECTOR;
    option (node_category_path) = "Functions/Vector";

    option (node_description) = "Vector function.";

    enum VisualShaderNodeVectorFuncType {
        FUNC_UNSPECIFIED = 0 [(value_caption) = "UNSPECIFIED"];
        FUNC_NORMALIZE = 1 [(value_caption) = "Normalize"];
        FUNC_SATURATE = 2 [(value_caption) = "Saturate"];
        FUNC_NEGATE = 3 [(value_caption) = "Negate"];
        FUNC_RECIPROCAL = 4 [(value_caption) = "Reciprocal"];
        FUNC_ABS = 5 [(value_caption) = "Abs"];
        FUNC_ACOS = 6 [(value_caption) = "Acos"];
        FUNC_ACOSH = 7 [(value_caption) = "Acosh"];
        FUNC_ASIN = 8 [(value_caption) = "Asin"];
        FUNC_ASINH = 9 [(value_caption) = "Asinh"];
        FUNC_ATAN = 10 [(value_caption) = "Atan"];
        FUNC_ATANH = 11 [(value_caption) = "Atanh"];
        FUNC_CEIL = 12 [(value_caption) = "Ceil"];
        FUNC_COS = 13 [(value_caption) = "Cos"];
        FUNC_COSH = 14 [(value_caption) = "Cosh"];
        FUNC_DEGREES = 15 [(value_caption) = "Degrees"];
        FUNC_EXP = 16 [(value_caption) = "Exp"];
        FUNC_EXP2 = 17 [(value_caption) = "Exp2"];
        FUNC_FLOOR = 18 [(value_caption) = "Floor"];
        FUNC_FRACT = 19 [(value_caption) = "Fract"];
        FUNC_INVERSE_SQRT = 20 [(value_caption) = "InverseSqrt"];
        FUNC_LOG = 21 [(value_caption) = "Log"];
        FUNC_LOG2 = 22 [(value_caption) = "Log2"];
        FUNC_RADIANS = 23 [(value_caption) = "Radians"];
        FUNC_ROUND = 24 [(value_caption) = "Round"];
        FUNC_ROUNDEVEN = 25 [(value_caption) = "RoundEven"];
        FUNC_SIGN = 26 [(value_caption) = "Sign"];
        FUNC_SIN = 27 [(value_caption) = "Sin"];
        FUNC_SINH = 28 [(value_caption) = "Sinh"];
        FUNC_SQRT = 29 [(value_caption) = "Sqrt"];
        FUNC_TAN = 30 [(value_caption) = "Tan"];
        FUNC_TANH = 31 [(value_caption) = "Tanh"];
        FUNC_TRUNC = 32 [(value_caption) = "Trunc"];
        FUNC_ONEMINUS = 33 [(value_caption) = "OneMinus"];
    };

    optional VisualShaderNodeVectorType type = 1;
    optional VisualShaderNodeVectorFuncType func = 2;
}

/*************************************/
/* NOISE                             */
/*************************************/

message VisualShaderNodeValueNoise {
    option (node_caption) = "ValueNoise";
    option (node_input_port_count) = 1;
    option (node_input_port_caption) = "uv";
    option (node_input_port_type) = PORT_TYPE_VECTOR_2D;
    
    option (node_output_port_count) = 1;
    option (node_output_port_caption) = "noise";
    option (node_output_port_type) = PORT_TYPE_VECTOR_4D;

    option (node_category) = CATEGORY_UNSPECIFIED;
    option (node_category_path) = "Procedural/Noise";

    option (node_description) = "Generates a simple, or Value, noise based on input 'UV'. The scale of the generated noise is controlled by input "
     "'Scale'.";

    optional float scale = 1;
}

message VisualShaderNodePerlinNoise {
    option (node_caption) = "PerlinNoise";
    option (node_input_port_count) = 1;
    option (node_input_port_caption) = "uv";
    option (node_input_port_type) = PORT_TYPE_VECTOR_2D;
    
    option (node_output_port_count) = 1;
    option (node_output_port_caption) = "noise";
    option (node_output_port_type) = PORT_TYPE_VECTOR_4D;

    option (node_category) = CATEGORY_UNSPECIFIED;
    option (node_category_path) = "Procedural/Noise";

    option (node_description) = "Generates a gradient, or Perlin, noise based on input 'UV'. The scale of the generated noise is controlled by "
     "input 'Scale'.";

    optional float scale = 1;
}

message VisualShaderNodeVoronoiNoise {
    option (node_caption) = "VoronoiNoise";
    option (node_input_port_count) = 1;
    option (node_input_port_caption) = "uv";
    option (node_input_port_type) = PORT_TYPE_VECTOR_2D;
    
    option (node_output_port_count) = 1;
    option (node_output_port_caption) = "noise";
    option (node_output_port_type) = PORT_TYPE_VECTOR_4D;

    option (node_category) = CATEGORY_UNSPECIFIED;
    option (node_category_path) = "Procedural/Noise";
    
    option (node_description) = "Generates a Voronoi, or Worley, noise based on input 'UV'. Voronoi noise is generated by calculating distances "
     "between a pixel and a lattice of points. By offsetting these points by a pseudo-random number, controlled by "
     "input 'Angle Offset', a cluster of cells can be generated. The scale of these cells, and the resulting noise, is "
     "controlled by input 'Cell Density'. The output 'Cells' contains the raw cell data.";

    optional float cell_density = 1;
    optional float angle_offset = 2;
}

/*************************************/
/* MISC                              */
/*************************************/

message VisualShaderNodeDotProduct {
    option (node_caption) = "DotProduct";
    option (node_input_port_count) = 2;
    option (node_input_port_caption) = "p1";
    option (node_input_port_type) = PORT_TYPE_VECTOR_3D;
    option (node_input_port_caption) = "p2";
    option (node_input_port_type) = PORT_TYPE_VECTOR_3D;
    
    option (node_output_port_count) = 1;
    option (node_output_port_caption) = "dot";
    option (node_output_port_type) = PORT_TYPE_SCALAR;

    option (node_category) = CATEGORY_VECTOR;
    option (node_category_path) = "Math/Vector";

    option (node_description) = "Calculates the dot product of two 3d vectors.";
}

message VisualShaderNodeVectorLen {
    option (node_caption) = "VectorLen";
    option (node_input_port_count) = 1;
    option (node_input_port_caption) = "";
    option (node_input_port_type) = PORT_TYPE_VECTOR_3D;
    
    option (node_output_port_count) = 1;
    option (node_output_port_caption) = "len";
    option (node_output_port_type) = PORT_TYPE_SCALAR;

    option (node_category) = CATEGORY_UNSPECIFIED;
    option (node_category_path) = "Math/Vector";

    option (node_description) = "Calculates the length of a vector.";

    optional VisualShaderNodeVectorType type = 1;
}

message VisualShaderNodeClamp {
    option (node_caption) = "Clamp";
    option (node_input_port_count) = 3;
    option (node_input_port_caption) = "x";
    option (node_input_port_type) = PORT_TYPE_UNSPECIFIED;
    option (node_input_port_caption) = "min";
    option (node_input_port_type) = PORT_TYPE_UNSPECIFIED;
    option (node_input_port_caption) = "max";
    option (node_input_port_type) = PORT_TYPE_UNSPECIFIED;
    
    option (node_output_port_count) = 1;
    option (node_output_port_caption) = "";
    option (node_output_port_type) = PORT_TYPE_UNSPECIFIED;

    option (node_category) = CATEGORY_UNSPECIFIED;
    option (node_category_path) = "Math/Scalar";

    option (node_description) = "Clamps a value between a minimum and a maximum value.";

    optional VisualShaderNodePortType type = 1;
}

message VisualShaderNodeStep {
    option (node_caption) = "Step";
    option (node_input_port_count) = 2;
    option (node_input_port_caption) = "edge";
    option (node_input_port_type) = PORT_TYPE_UNSPECIFIED;
    option (node_input_port_caption) = "x";
    option (node_input_port_type) = PORT_TYPE_UNSPECIFIED;
    
    option (node_output_port_count) = 1;
    option (node_output_port_caption) = "";
    option (node_output_port_type) = PORT_TYPE_UNSPECIFIED;

    option (node_category) = CATEGORY_UNSPECIFIED;
    option (node_category_path) = "Math/Scalar";

    option (node_description) = "Step function( scalar(edge), scalar(x) ).\n\nReturns 0.0 if 'x' is smaller than 'edge' and otherwise 1.0.";

    optional VisualShaderNodePortType type = 1;
}

message VisualShaderNodeSmoothStep {
    option (node_caption) = "SmoothStep";
    option (node_input_port_count) = 3;
    option (node_input_port_caption) = "edge0";
    option (node_input_port_type) = PORT_TYPE_UNSPECIFIED;
    option (node_input_port_caption) = "edge1";
    option (node_input_port_type) = PORT_TYPE_UNSPECIFIED;
    option (node_input_port_caption) = "x";
    option (node_input_port_type) = PORT_TYPE_UNSPECIFIED;
    
    option (node_output_port_count) = 1;
    option (node_output_port_caption) = "";
    option (node_output_port_type) = PORT_TYPE_UNSPECIFIED;

    option (node_category) = CATEGORY_UNSPECIFIED;
    option (node_category_path) = "Math/Scalar";

    option (node_description) = "SmoothStep function( scalar(edge0), scalar(edge1), scalar(x) ).\n\nReturns 0.0 if 'x' is smaller than 'edge0' "
     "and 1.0 if x is larger than 'edge1'. Otherwise the return value is interpolated between 0.0 and 1.0 using "
     "Hermite polynomials.";

    optional VisualShaderNodePortType type = 1;
}

message VisualShaderNodeVectorDistance {
    option (node_caption) = "VectorDistance";
    option (node_input_port_count) = 2;
    option (node_input_port_caption) = "p1";
    option (node_input_port_type) = PORT_TYPE_VECTOR_3D;
    option (node_input_port_caption) = "p2";
    option (node_input_port_type) = PORT_TYPE_VECTOR_3D;
    
    option (node_output_port_count) = 1;
    option (node_output_port_caption) = "";
    option (node_output_port_type) = PORT_TYPE_SCALAR;

    option (node_category) = CATEGORY_VECTOR;
    option (node_category_path) = "Math/Vector";

    option (node_description) = "Calculates the distance between two 3d vectors.";
}

message VisualShaderNodeMix {
    option (node_caption) = "Mix";
    option (node_input_port_count) = 3;
    option (node_input_port_caption) = "p1";
    option (node_input_port_type) = PORT_TYPE_UNSPECIFIED;
    option (node_input_port_caption) = "p2";
    option (node_input_port_type) = PORT_TYPE_UNSPECIFIED;
    option (node_input_port_caption) = "weight";
    option (node_input_port_type) = PORT_TYPE_UNSPECIFIED;
    
    option (node_output_port_count) = 1;
    option (node_output_port_caption) = "mix";
    option (node_output_port_type) = PORT_TYPE_UNSPECIFIED;

    option (node_category) = CATEGORY_UNSPECIFIED;
    option (node_category_path) = "Math/Scalar";

    option (node_description) = "Linearly interpolates between two values based on a third value.";

    optional VisualShaderNodePortType type = 1;
}

message VisualShaderNode2dVectorCompose {
    option (node_caption) = "2DVectorCompose";
    option (node_input_port_count) = 2;
    option (node_input_port_caption) = "x";
    option (node_input_port_type) = PORT_TYPE_SCALAR;
    option (node_input_port_caption) = "y";
    option (node_input_port_type) = PORT_TYPE_SCALAR;
    
    option (node_output_port_count) = 1;
    option (node_output_port_caption) = "v";
    option (node_output_port_type) = PORT_TYPE_VECTOR_2D;

    option (node_category) = CATEGORY_VECTOR;
    option (node_category_path) = "Math/Vector";

    option (node_description) = "Composes a 2D vector from two scalar values.";
}

message VisualShaderNode3dVectorCompose {
    option (node_caption) = "3DVectorCompose";
    option (node_input_port_count) = 3;
    option (node_input_port_caption) = "x";
    option (node_input_port_type) = PORT_TYPE_SCALAR;
    option (node_input_port_caption) = "y";
    option (node_input_port_type) = PORT_TYPE_SCALAR;
    option (node_input_port_caption) = "z";
    option (node_input_port_type) = PORT_TYPE_SCALAR;
    
    option (node_output_port_count) = 1;
    option (node_output_port_caption) = "v";
    option (node_output_port_type) = PORT_TYPE_VECTOR_3D;

    option (node_category) = CATEGORY_VECTOR;
    option (node_category_path) = "Math/Vector";

    option (node_description) = "Composes a 3D vector from three scalar values.";
}

message VisualShaderNode4dVectorCompose {
    option (node_caption) = "4DVectorCompose";
    option (node_input_port_count) = 4;
    option (node_input_port_caption) = "x";
    option (node_input_port_type) = PORT_TYPE_SCALAR;
    option (node_input_port_caption) = "y";
    option (node_input_port_type) = PORT_TYPE_SCALAR;
    option (node_input_port_caption) = "z";
    option (node_input_port_type) = PORT_TYPE_SCALAR;
    option (node_input_port_caption) = "w";
    option (node_input_port_type) = PORT_TYPE_SCALAR;
    
    option (node_output_port_count) = 1;
    option (node_output_port_caption) = "v";
    option (node_output_port_type) = PORT_TYPE_VECTOR_4D;

    option (node_category) = CATEGORY_VECTOR;
    option (node_category_path) = "Math/Vector";

    option (node_description) = "Composes a 4D vector from four scalar values.";
}

message VisualShaderNode2dVectorDecompose {
    option (node_caption) = "2DVectorDecompose";
    option (node_input_port_count) = 1;
    option (node_input_port_caption) = "v";
    option (node_input_port_type) = PORT_TYPE_VECTOR_2D;
    
    option (node_output_port_count) = 2;
    option (node_output_port_caption) = "x";
    option (node_output_port_type) = PORT_TYPE_SCALAR;
    option (node_output_port_caption) = "y";
    option (node_output_port_type) = PORT_TYPE_SCALAR;

    option (node_category) = CATEGORY_VECTOR;
    option (node_category_path) = "Math/Vector";

    option (node_description) = "Decomposes a 2D vector into two scalar values.";
}

message VisualShaderNode3dVectorDecompose {
    option (node_caption) = "3DVectorDecompose";
    option (node_input_port_count) = 1;
    option (node_input_port_caption) = "v";
    option (node_input_port_type) = PORT_TYPE_VECTOR_3D;
    
    option (node_output_port_count) = 3;
    option (node_output_port_caption) = "x";
    option (node_output_port_type) = PORT_TYPE_SCALAR;
    option (node_output_port_caption) = "y";
    option (node_output_port_type) = PORT_TYPE_SCALAR;
    option (node_output_port_caption) = "z";
    option (node_output_port_type) = PORT_TYPE_SCALAR;

    option (node_category) = CATEGORY_VECTOR;
    option (node_category_path) = "Math/Vector";

    option (node_description) = "Decomposes a 3D vector into three scalar values.";
}

message VisualShaderNode4dVectorDecompose {
    option (node_caption) = "4DVectorDecompose";
    option (node_input_port_count) = 1;
    option (node_input_port_caption) = "v";
    option (node_input_port_type) = PORT_TYPE_VECTOR_4D;
    
    option (node_output_port_count) = 4;
    option (node_output_port_caption) = "x";
    option (node_output_port_type) = PORT_TYPE_SCALAR;
    option (node_output_port_caption) = "y";
    option (node_output_port_type) = PORT_TYPE_SCALAR;
    option (node_output_port_caption) = "z";
    option (node_output_port_type) = PORT_TYPE_SCALAR;
    option (node_output_port_caption) = "w";
    option (node_output_port_type) = PORT_TYPE_SCALAR;

    option (node_category) = CATEGORY_VECTOR;
    option (node_category_path) = "Math/Vector";

    option (node_description) = "Decomposes a 4D vector into four scalar values.";
}

message VisualShaderNodeIf {
    option (node_caption) = "If";
    option (node_input_port_count) = 6;
    option (node_input_port_caption) = "p1";
    option (node_input_port_type) = PORT_TYPE_SCALAR;
    option (node_input_port_caption) = "p2";
    option (node_input_port_type) = PORT_TYPE_SCALAR;
    option (node_input_port_caption) = "tolerance";
    option (node_input_port_type) = PORT_TYPE_SCALAR;
    option (node_input_port_caption) = "p1 == p2";
    option (node_input_port_type) = PORT_TYPE_VECTOR_3D;
    option (node_input_port_caption) = "p1 > p2";
    option (node_input_port_type) = PORT_TYPE_VECTOR_3D;
    option (node_input_port_caption) = "p1 < p2";
    option (node_input_port_type) = PORT_TYPE_VECTOR_3D;

    option (node_output_port_count) = 1;
    option (node_output_port_caption) = "result";
    option (node_output_port_type) = PORT_TYPE_VECTOR_3D;

    option (node_category) = CATEGORY_CONDITIONAL;
    option (node_category_path) = "Logic";

    option (node_description) = "Returns the value of the 'True' or 'False' input based on the value of the 'Condition' input.";
}

message VisualShaderNodeSwitch {
    option (node_caption) = "Switch";
    option (node_input_port_count) = 3;
    option (node_input_port_caption) = "condition";
    option (node_input_port_type) = PORT_TYPE_BOOLEAN;
    option (node_input_port_caption) = "true";
    option (node_input_port_type) = PORT_TYPE_UNSPECIFIED;
    option (node_input_port_caption) = "false";
    option (node_input_port_type) = PORT_TYPE_UNSPECIFIED;

    option (node_output_port_count) = 1;
    option (node_output_port_caption) = "result";
    option (node_output_port_type) = PORT_TYPE_UNSPECIFIED;

    option (node_category) = CATEGORY_CONDITIONAL;
    option (node_category_path) = "Logic";

    option (node_description) = "Returns an associated scalar if the provided boolean value is true or false.";

    enum VisualShaderNodeSwitchOpType {
        OP_TYPE_UNSPECIFIED = 0 [(value_caption) = "UNSPECIFIED"];
        OP_TYPE_FLOAT = 1 [(value_caption) = "Float"];
        OP_TYPE_INT = 2 [(value_caption) = "Int"];
        OP_TYPE_UINT = 3 [(value_caption) = "UInt"];
        OP_TYPE_VECTOR_2D = 4 [(value_caption) = "Vector2"];
        OP_TYPE_VECTOR_3D = 5 [(value_caption) = "Vector3"];
        OP_TYPE_VECTOR_4D = 6 [(value_caption) = "Vector4"];
        OP_TYPE_BOOLEAN = 7 [(value_caption) = "Boolean"];
    };

    optional VisualShaderNodeSwitchOpType type = 1;
}

message VisualShaderNodeIs {
    option (node_caption) = "Is";
    option (node_input_port_count) = 1;
    option (node_input_port_caption) = "";
    option (node_input_port_type) = PORT_TYPE_SCALAR;

    option (node_output_port_count) = 1;
    option (node_output_port_caption) = "";
    option (node_output_port_type) = PORT_TYPE_BOOLEAN;

    option (node_category) = CATEGORY_CONDITIONAL;
    option (node_category_path) = "Logic";

    option (node_description) = "Returns the boolean result of the comparison between INF (or NaN) and a scalar parameter.";

    enum Function {
        FUNC_UNSPECIFIED = 0 [(value_caption) = "UNSPECIFIED"];
        FUNC_IS_INF = 1 [(value_caption) = "IsInf"];
        FUNC_IS_NAN = 2 [(value_caption) = "IsNan"];
    };

    optional Function func = 1;
}

message VisualShaderNodeCompare {
    option (node_caption) = "Compare";
    option (node_input_port_count) = 3;
    option (node_input_port_caption) = "p1";
    option (node_input_port_type) = PORT_TYPE_SCALAR;
    option (node_input_port_caption) = "p2";
    option (node_input_port_type) = PORT_TYPE_SCALAR;
    option (node_input_port_caption) = "op";
    option (node_input_port_type) = PORT_TYPE_SCALAR;

    option (node_output_port_count) = 1;
    option (node_output_port_caption) = "";
    option (node_output_port_type) = PORT_TYPE_BOOLEAN;

    option (node_category) = CATEGORY_CONDITIONAL;
    option (node_category_path) = "Logic";

    option (node_description) = "Returns the boolean result of the comparison between two parameters.";

    enum ComparisonType {
        CMP_TYPE_UNSPECIFIED = 0 [(value_caption) = "UNSPECIFIED"];
        CMP_TYPE_SCALAR = 1 [(value_caption) = "Scalar"];
        CMP_TYPE_SCALAR_INT = 2 [(value_caption) = "ScalarInt"];
        CMP_TYPE_SCALAR_UINT = 3 [(value_caption) = "ScalarUInt"];
        CMP_TYPE_VECTOR_2D = 4 [(value_caption) = "Vector2"];
        CMP_TYPE_VECTOR_3D = 5 [(value_caption) = "Vector3"];
        CMP_TYPE_VECTOR_4D = 6 [(value_caption) = "Vector4"];
        CMP_TYPE_BOOLEAN = 7 [(value_caption) = "Boolean"];
    };

    enum Function {
        FUNC_UNSPECIFIED = 0 [(value_caption) = "UNSPECIFIED"];
        FUNC_EQUAL = 1 [(value_caption) = "Equal"];
        FUNC_NOT_EQUAL = 2 [(value_caption) = "NotEqual"];
        FUNC_GREATER_THAN = 3 [(value_caption) = "GreaterThan"];
        FUNC_GREATER_THAN_EQUAL = 4 [(value_caption) = "GreaterThanEqual"];
        FUNC_LESS_THAN = 5 [(value_caption) = "LessThan"];
        FUNC_LESS_THAN_EQUAL = 6 [(value_caption) = "LessThanEqual"];
    };

    enum Condition {
        COND_UNSPECIFIED = 0 [(value_caption) = "UNSPECIFIED"];
        COND_ALL = 1 [(value_caption) = "All"];
        COND_ANY = 2 [(value_caption) = "Any"];
    };

    optional ComparisonType type = 1;
    optional Function func = 2;
    optional Condition cond = 3;
}


