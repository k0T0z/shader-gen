syntax = "proto3";
package gui.model.schema;

import "google/protobuf/descriptor.proto";

// https://protobuf.dev/programming-guides/proto3/#enum-default
enum VisualShaderNodePortType {
    PORT_TYPE_UNSPECIFIED = 0;
    PORT_TYPE_SCALAR = 1;
    PORT_TYPE_SCALAR_INT = 2;
    PORT_TYPE_SCALAR_UINT = 3;
    PORT_TYPE_VECTOR_2D = 4;
    PORT_TYPE_VECTOR_3D = 5;
    PORT_TYPE_VECTOR_4D = 6;
    PORT_TYPE_BOOLEAN = 7;
};

enum VisualShaderNodeCategory {
    CATEGORY_UNSPECIFIED = 0;
    CATEGORY_INPUT = 1;
    CATEGORY_OUTPUT = 2;
    CATEGORY_SCALAR = 3;
    CATEGORY_VECTOR = 4;
    CATEGORY_COLOR = 5;
    CATEGORY_CONDITIONAL = 6;
    CATEGORY_UTILITY = 7;
};

enum VisualShaderNodeVectorType {
    TYPE_VECTOR_UNSPECIFIED = 0;
    TYPE_VECTOR_2D = 1;
    TYPE_VECTOR_3D = 2;
    TYPE_VECTOR_4D = 3;
};

// See:
// https://protobuf.dev/programming-guides/extension_declarations/
// https://protobuf.dev/programming-guides/proto2/#extensions
// https://protobuf.dev/programming-guides/proto3/#options
// https://protobuf.dev/programming-guides/proto3/#customoptions
// https://protobuf.dev/reference/protobuf/proto3-spec/#option
extend google.protobuf.MessageOptions {
    optional int32 mo_id_start = 60000;
    string node_caption = 60001;

    int32 node_input_port_count = 60002;
    repeated string node_input_port_caption = 60003;
    repeated VisualShaderNodePortType node_input_port_type = 60004;

    int32 node_output_port_count = 60005;
    repeated string node_output_port_caption = 60006;
    repeated VisualShaderNodePortType node_output_port_type = 60007;

    string node_category_path = 60008;
    VisualShaderNodeCategory node_category = 60009;

    string node_description = 60010;

    // Input node specifics
    optional int32 input_type_count = 60011;
    repeated VisualShaderNodeInputType input_type = 60012;
    repeated VisualShaderNodePortType input_node_output_port_type = 60013;

    // Output node specifics
    optional int32 output_type_count = 60014;
    repeated VisualShaderNodeOutputType output_type = 60015;
    repeated VisualShaderNodePortType output_node_input_port_type = 60016;

    // Operators specifics
    optional int32 operator_type_count = 60017;
}

extend google.protobuf.EnumValueOptions {
    optional string eo_id_start = 70000;
    optional string type_caption = 70001;
}

/*************************************/
/* Input Node                        */
/*************************************/

enum VisualShaderNodeInputType {
    INPUT_TYPE_UNSPECIFIED = 0 [(type_caption) = "UNSPECIFIED"];
    INPUT_TYPE_UV = 1 [(type_caption) = "UV"];
    INPUT_TYPE_TIME = 2 [(type_caption) = "Time"];
};

message VisualShaderNodeInput {
    option (node_caption) = "Input";
    option (node_input_port_count) = 0;
    
    option (node_output_port_count) = 1;

    option (node_category_path) = "Input/Basic";

    option (node_description) = "Input node that can be used to pass a value into the shader.";

    option (input_type_count) = 3;

    option (input_type) = INPUT_TYPE_UNSPECIFIED;
    option (input_node_output_port_type) = PORT_TYPE_UNSPECIFIED;

    option (input_type) = INPUT_TYPE_UV;
    option (input_node_output_port_type) = PORT_TYPE_VECTOR_2D;
    
    option (input_type) = INPUT_TYPE_TIME;
    option (input_node_output_port_type) = PORT_TYPE_SCALAR;

    optional VisualShaderNodeInputType type = 1;
}

/*************************************/
/* Output Node                       */
/*************************************/

enum VisualShaderNodeOutputType {
    OUTPUT_TYPE_UNSPECIFIED = 0 [(type_caption) = "UNSPECIFIED"];
    OUTPUT_TYPE_COLOR = 1 [(type_caption) = "Color"];
};

message VisualShaderNodeOutput {
    option (node_caption) = "Output";
    option (node_input_port_count) = 1;
    
    option (node_output_port_count) = 0;

    option (node_description) = "Output node can not be added/removed, it is always present in the shader graph.";

    option (output_type_count) = 2;

    option (output_type) = OUTPUT_TYPE_UNSPECIFIED;
    option (output_node_input_port_type) = PORT_TYPE_UNSPECIFIED;

    option (output_type) = OUTPUT_TYPE_COLOR;
    option (output_node_input_port_type) = PORT_TYPE_VECTOR_4D;

    optional VisualShaderNodeOutputType type = 1;
}

/*************************************/
/* CONSTANTS                         */
/*************************************/

message VisualShaderNodeFloatConstant {
    option (node_caption) = "FloatConstant";
    option (node_input_port_count) = 0;
    
    option (node_output_port_count) = 1;
    option (node_output_port_type) = PORT_TYPE_SCALAR;

    option (node_category) = CATEGORY_INPUT;
    option (node_category_path) = "Input/Basic";

    option (node_description) = "Scalar floating-point constant.";

    optional float value = 1;
}

message VisualShaderNodeIntConstant {
    option (node_caption) = "IntConstant";
    option (node_input_port_count) = 0;
    
    option (node_output_port_count) = 1;
    option (node_output_port_type) = PORT_TYPE_SCALAR_INT;

    option (node_category) = CATEGORY_INPUT;
    option (node_category_path) = "Input/Basic";

    option (node_description) = "Scalar integer constant.";

    optional int32 value = 1;
}

message VisualShaderNodeUIntConstant {
    option (node_caption) = "UIntConstant";
    option (node_input_port_count) = 0;
    
    option (node_output_port_count) = 1;
    option (node_output_port_type) = PORT_TYPE_SCALAR_UINT;

    option (node_category) = CATEGORY_INPUT;
    option (node_category_path) = "Input/Basic";

    option (node_description) = "Scalar unsigned integer constant.";

    optional uint32 value = 1;
}

message VisualShaderNodeBooleanConstant {
    option (node_caption) = "BooleanConstant";
    option (node_input_port_count) = 0;
    
    option (node_output_port_count) = 1;
    option (node_output_port_type) = PORT_TYPE_BOOLEAN;

    option (node_category) = CATEGORY_INPUT;
    option (node_category_path) = "Input/Basic";

    option (node_description) = "Scalar boolean constant.";

    optional bool value = 1;
}

message VisualShaderNodeColorConstant {
    option (node_caption) = "ColorConstant";
    option (node_input_port_count) = 0;
    
    option (node_output_port_count) = 1;
    option (node_output_port_type) = PORT_TYPE_VECTOR_4D;

    option (node_category) = CATEGORY_INPUT;
    option (node_category_path) = "Input/Basic";

    option (node_description) = "Vector color constant.";

    optional float r = 1;
    optional float g = 2;
    optional float b = 3;
    optional float a = 4;
}

message VisualShaderNodeVec2Constant {
    option (node_caption) = "Vec2Constant";
    option (node_input_port_count) = 0;
    
    option (node_output_port_count) = 1;
    option (node_output_port_type) = PORT_TYPE_VECTOR_2D;

    option (node_category) = CATEGORY_INPUT;
    option (node_category_path) = "Input/Basic";

    option (node_description) = "Vector 2D constant.";

    optional float x = 1;
    optional float y = 2;
}

message VisualShaderNodeVec3Constant {
    option (node_caption) = "Vec3Constant";
    option (node_input_port_count) = 0;
    
    option (node_output_port_count) = 1;
    option (node_output_port_type) = PORT_TYPE_VECTOR_3D;

    option (node_category) = CATEGORY_INPUT;
    option (node_category_path) = "Input/Basic";

    option (node_description) = "Vector 3D constant.";

    optional float x = 1;
    optional float y = 2;
    optional float z = 3;
}

message VisualShaderNodeVec4Constant {
    option (node_caption) = "Vec4Constant";
    option (node_input_port_count) = 0;
    
    option (node_output_port_count) = 1;
    option (node_output_port_type) = PORT_TYPE_VECTOR_4D;

    option (node_category) = CATEGORY_INPUT;
    option (node_category_path) = "Input/Basic";

    option (node_description) = "Vector 4D constant.";

    optional float x = 1;
    optional float y = 2;
    optional float z = 3;
    optional float w = 4;
}

/*************************************/
/* OPERATORS                         */
/*************************************/

message VisualShaderNodeFloatOp {
    option (node_caption) = "FloatOp";

    option (node_input_port_count) = 2;

    option (node_input_port_type) = PORT_TYPE_SCALAR;
    option (node_input_port_caption) = "p1";

    option (node_input_port_type) = PORT_TYPE_SCALAR;
    option (node_input_port_caption) = "p2";
    
    option (node_output_port_count) = 1;
    option (node_output_port_type) = PORT_TYPE_SCALAR;
    option (node_output_port_caption) = "op";

    option (node_category) = CATEGORY_SCALAR;
    option (node_category_path) = "Operators/Scalar";

    option (node_description) = "Scalar floating-point operator.";

    option (operator_type_count) = 10;

    enum VisualShaderNodeFloatOpType {
        OP_UNSPECIFIED = 0 [(type_caption) = "UNSPECIFIED"];
        OP_ADD = 1 [(type_caption) = "Add"];
        OP_SUB = 2 [(type_caption) = "Subtract"];
        OP_MUL = 3 [(type_caption) = "Multiply"];
        OP_DIV = 4 [(type_caption) = "Divide"];
        OP_MOD = 5 [(type_caption) = "Modulo"];
        OP_POW = 6 [(type_caption) = "Power"];
        OP_MAX = 7 [(type_caption) = "Max"];
        OP_MIN = 8 [(type_caption) = "Min"];
        OP_ATAN2 = 9 [(type_caption) = "Atan2"];
        OP_STEP = 10 [(type_caption) = "Step"];
    };

    optional VisualShaderNodeFloatOpType op = 1;
}

message VisualShaderNodeIntOp {
    option (node_caption) = "IntOp";

    option (node_input_port_count) = 2;

    option (node_input_port_type) = PORT_TYPE_SCALAR_INT;
    option (node_input_port_caption) = "p1";

    option (node_input_port_type) = PORT_TYPE_SCALAR_INT;
    option (node_input_port_caption) = "p2";
    
    option (node_output_port_count) = 1;
    option (node_output_port_type) = PORT_TYPE_SCALAR_INT;
    option (node_output_port_caption) = "op";

    option (node_category) = CATEGORY_SCALAR;
    option (node_category_path) = "Operators/Scalar";

    option (node_description) = "Scalar integer operator.";

    option (operator_type_count) = 12;

    enum VisualShaderNodeIntOpType {
        OP_UNSPECIFIED = 0 [(type_caption) = "UNSPECIFIED"];
        OP_ADD = 1 [(type_caption) = "Add"];
        OP_SUB = 2 [(type_caption) = "Subtract"];
        OP_MUL = 3 [(type_caption) = "Multiply"];
        OP_DIV = 4 [(type_caption) = "Divide"];
        OP_MOD = 5 [(type_caption) = "Modulo"];
        OP_MAX = 6 [(type_caption) = "Max"];
        OP_MIN = 7 [(type_caption) = "Min"];
        OP_BITWISE_AND = 8 [(type_caption) = "BitwiseAnd"];
        OP_BITWISE_OR = 9 [(type_caption) = "BitwiseOr"];
        OP_BITWISE_XOR = 10 [(type_caption) = "BitwiseXor"];
        OP_BITWISE_LEFT_SHIFT = 11 [(type_caption) = "BitwiseLeftShift"];
        OP_BITWISE_RIGHT_SHIFT = 12 [(type_caption) = "BitwiseRightShift"];
    };

    optional VisualShaderNodeIntOpType op = 1;
}

message VisualShaderNodeUIntOp {
    option (node_caption) = "UIntOp";

    option (node_input_port_count) = 2;

    option (node_input_port_type) = PORT_TYPE_SCALAR_UINT;
    option (node_input_port_caption) = "p1";

    option (node_input_port_type) = PORT_TYPE_SCALAR_UINT;
    option (node_input_port_caption) = "p2";
    
    option (node_output_port_count) = 1;
    option (node_output_port_type) = PORT_TYPE_SCALAR_UINT;
    option (node_output_port_caption) = "op";

    option (node_category) = CATEGORY_SCALAR;
    option (node_category_path) = "Operators/Scalar";

    option (node_description) = "Scalar unsigned integer operator.";

    option (operator_type_count) = 12;

    enum VisualShaderNodeUIntOpType {
        OP_UNSPECIFIED = 0 [(type_caption) = "UNSPECIFIED"];
        OP_ADD = 1 [(type_caption) = "Add"];
        OP_SUB = 2 [(type_caption) = "Subtract"];
        OP_MUL = 3 [(type_caption) = "Multiply"];
        OP_DIV = 4 [(type_caption) = "Divide"];
        OP_MOD = 5 [(type_caption) = "Modulo"];
        OP_MAX = 6 [(type_caption) = "Max"];
        OP_MIN = 7 [(type_caption) = "Min"];
        OP_BITWISE_AND = 8 [(type_caption) = "BitwiseAnd"];
        OP_BITWISE_OR = 9 [(type_caption) = "BitwiseOr"];
        OP_BITWISE_XOR = 10 [(type_caption) = "BitwiseXor"];
        OP_BITWISE_LEFT_SHIFT = 11 [(type_caption) = "BitwiseLeftShift"];
        OP_BITWISE_RIGHT_SHIFT = 12 [(type_caption) = "BitwiseRightShift"];
    };

    optional VisualShaderNodeUIntOpType op = 1;
}

message VisualShaderNodeVectorOp {
    option (node_caption) = "VectorOp";

    option (node_input_port_count) = 2;

    option (node_input_port_caption) = "p1";

    option (node_input_port_caption) = "p2";
    
    option (node_output_port_count) = 1;

    option (node_output_port_caption) = "op";

    option (node_category) = CATEGORY_VECTOR;
    option (node_category_path) = "Operators/Vector";

    option (node_description) = "Vector operator.";

    option (operator_type_count) = 12;

    enum VisualShaderNodeVectorOpType {
        OP_UNSPECIFIED = 0 [(type_caption) = "UNSPECIFIED"];
        OP_ADD = 1 [(type_caption) = "Add"];
        OP_SUB = 2 [(type_caption) = "Subtract"];
        OP_MUL = 3 [(type_caption) = "Multiply"];
        OP_DIV = 4 [(type_caption) = "Divide"];
        OP_MOD = 5 [(type_caption) = "Modulo"];
        OP_POW = 6 [(type_caption) = "Power"];
        OP_MAX = 7 [(type_caption) = "Max"];
        OP_MIN = 8 [(type_caption) = "Min"];
        OP_CROSS = 9 [(type_caption) = "Cross"];
        OP_ATAN2 = 10 [(type_caption) = "Atan2"];
        OP_REFLECT = 11 [(type_caption) = "Reflect"];
        OP_STEP = 12 [(type_caption) = "Step"];
    };

    optional VisualShaderNodeVectorType type = 1;
    optional VisualShaderNodeVectorOpType op = 2;
}

/*************************************/
/* Funcs Node                        */
/*************************************/

message VisualShaderNodeFloatFunc {
    option (node_caption) = "FloatFunc";

    option (node_input_port_count) = 1;

    option (node_input_port_type) = PORT_TYPE_SCALAR;
    option (node_input_port_caption) = "p";
    
    option (node_output_port_count) = 1;
    option (node_output_port_type) = PORT_TYPE_SCALAR;
    option (node_output_port_caption) = "func";

    option (node_category) = CATEGORY_SCALAR;
    option (node_category_path) = "Functions/Scalar";

    option (node_description) = "Scalar floating-point function.";

    option (operator_type_count) = 32;

    enum VisualShaderNodeFloatFuncType {
        FUNC_UNSPECIFIED = 0 [(type_caption) = "UNSPECIFIED"];
        FUNC_SIN = 1 [(type_caption) = "Sin"];
        FUNC_COS = 2 [(type_caption) = "Cos"];
        FUNC_TAN = 3 [(type_caption) = "Tan"];
        FUNC_ASIN = 4 [(type_caption) = "Asin"];
        FUNC_ACOS = 5 [(type_caption) = "Acos"];
        FUNC_ATAN = 6 [(type_caption) = "Atan"];
        FUNC_SINH = 7 [(type_caption) = "Sinh"];
        FUNC_COSH = 8 [(type_caption) = "Cosh"];
        FUNC_TANH = 9 [(type_caption) = "Tanh"];
        FUNC_LOG = 10 [(type_caption) = "Log"];
        FUNC_EXP = 11 [(type_caption) = "Exp"];
        FUNC_SQRT = 12 [(type_caption) = "Sqrt"];
        FUNC_ABS = 13 [(type_caption) = "Abs"];
        FUNC_SIGN = 14 [(type_caption) = "Sign"];
        FUNC_FLOOR = 15 [(type_caption) = "Floor"];
        FUNC_ROUND = 16 [(type_caption) = "Round"];
        FUNC_CEIL = 17 [(type_caption) = "Ceil"];
        FUNC_FRACT = 18 [(type_caption) = "Fract"];
        FUNC_SATURATE = 19 [(type_caption) = "Saturate"];
        FUNC_NEGATE = 20 [(type_caption) = "Negate"];
        FUNC_ACOSH = 21 [(type_caption) = "Acosh"];
        FUNC_ASINH = 22 [(type_caption) = "Asinh"];
        FUNC_ATANH = 23 [(type_caption) = "Atanh"];
        FUNC_DEGREES = 24 [(type_caption) = "Degrees"];
        FUNC_EXP2 = 25 [(type_caption) = "Exp2"];
        FUNC_INVERSE_SQRT = 26 [(type_caption) = "InverseSqrt"];
        FUNC_LOG2 = 27 [(type_caption) = "Log2"];
        FUNC_RADIANS = 28 [(type_caption) = "Radians"];
        FUNC_RECIPROCAL = 29 [(type_caption) = "Reciprocal"];
        FUNC_ROUNDEVEN = 30 [(type_caption) = "RoundEven"];
        FUNC_TRUNC = 31 [(type_caption) = "Trunc"];
        FUNC_ONEMINUS = 32 [(type_caption) = "OneMinus"];
    };

    optional VisualShaderNodeFloatFuncType func = 1;
}

message VisualShaderNodeIntFunc {
    option (node_caption) = "IntFunc";

    option (node_input_port_count) = 1;

    option (node_input_port_type) = PORT_TYPE_SCALAR_INT;
    option (node_input_port_caption) = "p";
    
    option (node_output_port_count) = 1;
    option (node_output_port_type) = PORT_TYPE_SCALAR_INT;
    option (node_output_port_caption) = "func";

    option (node_category) = CATEGORY_SCALAR;
    option (node_category_path) = "Functions/Scalar";

    option (node_description) = "Scalar integer function.";

    option (operator_type_count) = 4;

    enum VisualShaderNodeIntFuncType {
        FUNC_UNSPECIFIED = 0 [(type_caption) = "UNSPECIFIED"];
        FUNC_ABS = 1 [(type_caption) = "Abs"];
        FUNC_NEGATE = 2 [(type_caption) = "Negate"];
        FUNC_SIGN = 3 [(type_caption) = "Sign"];
        FUNC_BITWISE_NOT = 4 [(type_caption) = "BitwiseNot"];
    };

    optional VisualShaderNodeIntFuncType func = 1;
}

message VisualShaderNodeUIntFunc {
    option (node_caption) = "UIntFunc";

    option (node_input_port_count) = 1;

    option (node_input_port_type) = PORT_TYPE_SCALAR_UINT;
    option (node_input_port_caption) = "p";
    
    option (node_output_port_count) = 1;
    option (node_output_port_type) = PORT_TYPE_SCALAR_UINT;
    option (node_output_port_caption) = "func";

    option (node_category) = CATEGORY_SCALAR;
    option (node_category_path) = "Functions/Scalar";

    option (node_description) = "Scalar unsigned integer function.";

    option (operator_type_count) = 4;

    enum VisualShaderNodeUIntFuncType {
        FUNC_UNSPECIFIED = 0 [(type_caption) = "UNSPECIFIED"];
        FUNC_NEGATE = 1 [(type_caption) = "Negate"];
        FUNC_BITWISE_NOT = 2 [(type_caption) = "BitwiseNot"];
    };

    optional VisualShaderNodeUIntFuncType func = 1;
}

message VisualShaderNodeVectorFunc {
    option (node_caption) = "VectorFunc";

    option (node_input_port_count) = 1;

    option (node_input_port_caption) = "p";
    
    option (node_output_port_count) = 1;
    option (node_output_port_caption) = "func";

    option (node_category) = CATEGORY_VECTOR;
    option (node_category_path) = "Functions/Vector";

    option (node_description) = "Vector function.";

    option (operator_type_count) = 33;

    enum VisualShaderNodeVectorFuncType {
        FUNC_UNSPECIFIED = 0 [(type_caption) = "UNSPECIFIED"];
        FUNC_NORMALIZE = 1 [(type_caption) = "Normalize"];
        FUNC_SATURATE = 2 [(type_caption) = "Saturate"];
        FUNC_NEGATE = 3 [(type_caption) = "Negate"];
        FUNC_RECIPROCAL = 4 [(type_caption) = "Reciprocal"];
        FUNC_ABS = 5 [(type_caption) = "Abs"];
        FUNC_ACOS = 6 [(type_caption) = "Acos"];
        FUNC_ACOSH = 7 [(type_caption) = "Acosh"];
        FUNC_ASIN = 8 [(type_caption) = "Asin"];
        FUNC_ASINH = 9 [(type_caption) = "Asinh"];
        FUNC_ATAN = 10 [(type_caption) = "Atan"];
        FUNC_ATANH = 11 [(type_caption) = "Atanh"];
        FUNC_CEIL = 12 [(type_caption) = "Ceil"];
        FUNC_COS = 13 [(type_caption) = "Cos"];
        FUNC_COSH = 14 [(type_caption) = "Cosh"];
        FUNC_DEGREES = 15 [(type_caption) = "Degrees"];
        FUNC_EXP = 16 [(type_caption) = "Exp"];
        FUNC_EXP2 = 17 [(type_caption) = "Exp2"];
        FUNC_FLOOR = 18 [(type_caption) = "Floor"];
        FUNC_FRACT = 19 [(type_caption) = "Fract"];
        FUNC_INVERSE_SQRT = 20 [(type_caption) = "InverseSqrt"];
        FUNC_LOG = 21 [(type_caption) = "Log"];
        FUNC_LOG2 = 22 [(type_caption) = "Log2"];
        FUNC_RADIANS = 23 [(type_caption) = "Radians"];
        FUNC_ROUND = 24 [(type_caption) = "Round"];
        FUNC_ROUNDEVEN = 25 [(type_caption) = "RoundEven"];
        FUNC_SIGN = 26 [(type_caption) = "Sign"];
        FUNC_SIN = 27 [(type_caption) = "Sin"];
        FUNC_SINH = 28 [(type_caption) = "Sinh"];
        FUNC_SQRT = 29 [(type_caption) = "Sqrt"];
        FUNC_TAN = 30 [(type_caption) = "Tan"];
        FUNC_TANH = 31 [(type_caption) = "Tanh"];
        FUNC_TRUNC = 32 [(type_caption) = "Trunc"];
        FUNC_ONEMINUS = 33 [(type_caption) = "OneMinus"];
    };

    optional VisualShaderNodeVectorType type = 1;
    optional VisualShaderNodeVectorFuncType func = 2;
}

/*************************************/
/* NOISE                             */
/*************************************/

message VisualShaderNodeValueNoise {
    option (node_caption) = "Value Noise";
    option (node_input_port_count) = 1;
    option (node_input_port_type) = PORT_TYPE_VECTOR_2D;
    option (node_input_port_caption) = "uv";
    
    option (node_output_port_count) = 1;
    option (node_output_port_type) = PORT_TYPE_VECTOR_4D;
    option (node_output_port_caption) = "noise";

    option (node_category) = CATEGORY_UNSPECIFIED;
    option (node_category_path) = "Procedural/Noise";

    option (node_description) = "Generates a simple, or Value, noise based on input 'UV'. The scale of the generated noise is controlled by input "
     "'Scale'.";

    optional float scale = 1;
}

message VisualShaderNodePerlinNoise {
    option (node_caption) = "Perlin Noise";
    option (node_input_port_count) = 1;
    option (node_input_port_type) = PORT_TYPE_VECTOR_2D;
    option (node_input_port_caption) = "uv";
    
    option (node_output_port_count) = 1;
    option (node_output_port_type) = PORT_TYPE_VECTOR_4D;
    option (node_output_port_caption) = "noise";

    option (node_category) = CATEGORY_UNSPECIFIED;
    option (node_category_path) = "Procedural/Noise";

    option (node_description) = "Generates a gradient, or Perlin, noise based on input 'UV'. The scale of the generated noise is controlled by "
     "input 'Scale'.";

    optional float scale = 1;
}

message VisualShaderNodeVoronoiNoise {
    option (node_caption) = "Voronoi Noise";
    option (node_input_port_count) = 1;
    option (node_input_port_type) = PORT_TYPE_VECTOR_2D;
    option (node_input_port_caption) = "uv";
    
    option (node_output_port_count) = 1;
    option (node_output_port_type) = PORT_TYPE_VECTOR_4D;
    option (node_output_port_caption) = "noise";

    option (node_category) = CATEGORY_UNSPECIFIED;
    option (node_category_path) = "Procedural/Noise";
    
    option (node_description) = "Generates a Voronoi, or Worley, noise based on input 'UV'. Voronoi noise is generated by calculating distances "
     "between a pixel and a lattice of points. By offsetting these points by a pseudo-random number, controlled by "
     "input 'Angle Offset', a cluster of cells can be generated. The scale of these cells, and the resulting noise, is "
     "controlled by input 'Cell Density'. The output 'Cells' contains the raw cell data.";

    optional float cell_density = 1;
    optional float angle_offset = 2;
}


