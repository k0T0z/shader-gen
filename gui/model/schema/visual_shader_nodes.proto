syntax = "proto3";
package gui.model.schema;

import "google/protobuf/descriptor.proto";

// https://protobuf.dev/programming-guides/proto3/#enum-default
enum VisualShaderNodePortType {
    PORT_TYPE_UNSPECIFIED = 0;
    PORT_TYPE_SCALAR = 1;
    PORT_TYPE_SCALAR_INT = 2;
    PORT_TYPE_SCALAR_UINT = 3;
    PORT_TYPE_VECTOR_2D = 4;
    PORT_TYPE_VECTOR_3D = 5;
    PORT_TYPE_VECTOR_4D = 6;
    PORT_TYPE_BOOLEAN = 7;
};

enum VisualShaderNodeCategory {
    CATEGORY_UNSPECIFIED = 0;
    CATEGORY_OUTPUT = 1;
    CATEGORY_COLOR = 2;
    CATEGORY_CONDITIONAL = 3;
    CATEGORY_INPUT = 4;
    CATEGORY_SCALAR = 5;
    CATEGORY_UTILITY = 6;
    CATEGORY_VECTOR = 7;
};

// See:
// https://protobuf.dev/programming-guides/extension_declarations/
// https://protobuf.dev/programming-guides/proto2/#extensions
// https://protobuf.dev/programming-guides/proto3/#options
// https://protobuf.dev/programming-guides/proto3/#customoptions
// https://protobuf.dev/reference/protobuf/proto3-spec/#option
extend google.protobuf.MessageOptions {
    optional int32 id_start = 60000;
    string node_caption = 60001;
    int32 node_input_port_count = 60002;
    repeated VisualShaderNodePortType node_input_port_type = 60003;
    repeated string node_input_port_caption = 60004;
    int32 node_output_port_count = 60005;
    repeated VisualShaderNodePortType node_output_port_type = 60006;
    repeated string node_output_port_caption = 60007;
    VisualShaderNodeCategory node_category = 60008;
    string node_category_path = 60009;
    string node_description = 60010;
}

/*************************************/
/* CONSTANTS                         */
/*************************************/

message VisualShaderNodeFloatConstant {
    option (node_caption) = "Float Constant";
    option (node_input_port_count) = 0;
    
    option (node_output_port_count) = 1;
    option (node_output_port_type) = PORT_TYPE_SCALAR;
    option (node_output_port_caption) = "";

    option (node_category) = CATEGORY_INPUT;
    option (node_category_path) = "Input/Basic";
    option (node_description) = "Scalar floating-point constant.";

    optional float value = 1;
}

message VisualShaderNodeIntConstant {
    option (node_caption) = "Int Constant";
    option (node_input_port_count) = 0;
    
    option (node_output_port_count) = 1;
    option (node_output_port_type) = PORT_TYPE_SCALAR_INT;
    option (node_output_port_caption) = "";

    option (node_category) = CATEGORY_INPUT;
    option (node_category_path) = "Input/Basic";
    option (node_description) = "Scalar integer constant.";

    optional int32 value = 1;
}

message VisualShaderNodeUIntConstant {
    option (node_caption) = "UInt Constant";
    option (node_input_port_count) = 0;
    
    option (node_output_port_count) = 1;
    option (node_output_port_type) = PORT_TYPE_SCALAR_UINT;
    option (node_output_port_caption) = "";

    option (node_category) = CATEGORY_INPUT;
    option (node_category_path) = "Input/Basic";
    option (node_description) = "Scalar unsigned integer constant.";

    optional uint32 value = 1;
}

message VisualShaderNodeBooleanConstant {
    option (node_caption) = "Boolean Constant";
    option (node_input_port_count) = 0;
    
    option (node_output_port_count) = 1;
    option (node_output_port_type) = PORT_TYPE_BOOLEAN;
    option (node_output_port_caption) = "";

    option (node_category) = CATEGORY_INPUT;
    option (node_category_path) = "Input/Basic";
    option (node_description) = "Scalar boolean constant.";

    optional bool value = 1;
}

message VisualShaderNodeColorConstant {
    option (node_caption) = "Color Constant";
    option (node_input_port_count) = 0;
    
    option (node_output_port_count) = 1;
    option (node_output_port_type) = PORT_TYPE_VECTOR_4D;
    option (node_output_port_caption) = "";

    option (node_category) = CATEGORY_INPUT;
    option (node_category_path) = "Input/Basic";
    option (node_description) = "Vector color constant.";

    optional float r = 1;
    optional float g = 2;
    optional float b = 3;
    optional float a = 4;
}

message VisualShaderNodeVec2Constant {
    option (node_caption) = "Vec2 Constant";
    option (node_input_port_count) = 0;
    
    option (node_output_port_count) = 1;
    option (node_output_port_type) = PORT_TYPE_VECTOR_2D;
    option (node_output_port_caption) = "";

    option (node_category) = CATEGORY_INPUT;
    option (node_category_path) = "Input/Basic";
    option (node_description) = "Vector 2D constant.";

    optional float x = 1;
    optional float y = 2;
}

message VisualShaderNodeVec3Constant {
    option (node_caption) = "Vec3 Constant";
    option (node_input_port_count) = 0;
    
    option (node_output_port_count) = 1;
    option (node_output_port_type) = PORT_TYPE_VECTOR_3D;
    option (node_output_port_caption) = "";

    option (node_category) = CATEGORY_INPUT;
    option (node_category_path) = "Input/Basic";
    option (node_description) = "Vector 3D constant.";

    optional float x = 1;
    optional float y = 2;
    optional float z = 3;
}

message VisualShaderNodeVec4Constant {
    option (node_caption) = "Vec4 Constant";
    option (node_input_port_count) = 0;
    
    option (node_output_port_count) = 1;
    option (node_output_port_type) = PORT_TYPE_VECTOR_4D;
    option (node_output_port_caption) = "";

    option (node_category) = CATEGORY_INPUT;
    option (node_category_path) = "Input/Basic";
    option (node_description) = "Vector 4D constant.";

    optional float x = 1;
    optional float y = 2;
    optional float z = 3;
    optional float w = 4;
}

/*************************************/
/* OPERATORS                         */
/*************************************/


/*************************************/
/* NOISE                             */
/*************************************/

message VisualShaderNodeValueNoise {
    option (node_caption) = "Value Noise";
    option (node_input_port_count) = 1;
    option (node_input_port_type) = PORT_TYPE_VECTOR_2D;
    option (node_input_port_caption) = "uv";
    
    option (node_output_port_count) = 1;
    option (node_output_port_type) = PORT_TYPE_VECTOR_4D;
    option (node_output_port_caption) = "noise";

    option (node_category) = CATEGORY_UNSPECIFIED;
    option (node_category_path) = "Procedural/Noise";
    option (node_description) = "Generates a simple, or Value, noise based on input 'UV'. The scale of the generated noise is controlled by input "
     "'Scale'.";

    optional float scale = 1;
}

message VisualShaderNodePerlinNoise {
    option (node_caption) = "Perlin Noise";
    option (node_input_port_count) = 1;
    option (node_input_port_type) = PORT_TYPE_VECTOR_2D;
    option (node_input_port_caption) = "uv";
    
    option (node_output_port_count) = 1;
    option (node_output_port_type) = PORT_TYPE_VECTOR_4D;
    option (node_output_port_caption) = "noise";

    option (node_category) = CATEGORY_UNSPECIFIED;
    option (node_category_path) = "Procedural/Noise";
    option (node_description) = "Generates a gradient, or Perlin, noise based on input 'UV'. The scale of the generated noise is controlled by "
     "input 'Scale'.";

    optional float scale = 1;
}

message VisualShaderNodeVoronoiNoise {
    option (node_caption) = "Voronoi Noise";
    option (node_input_port_count) = 1;
    option (node_input_port_type) = PORT_TYPE_VECTOR_2D;
    option (node_input_port_caption) = "uv";
    
    option (node_output_port_count) = 1;
    option (node_output_port_type) = PORT_TYPE_VECTOR_4D;
    option (node_output_port_caption) = "noise";

    option (node_category) = CATEGORY_UNSPECIFIED;
    option (node_category_path) = "Procedural/Noise";
    option (node_description) = "Generates a Voronoi, or Worley, noise based on input 'UV'. Voronoi noise is generated by calculating distances "
     "between a pixel and a lattice of points. By offsetting these points by a pseudo-random number, controlled by "
     "input 'Angle Offset', a cluster of cells can be generated. The scale of these cells, and the resulting noise, is "
     "controlled by input 'Cell Density'. The output 'Cells' contains the raw cell data.";

    optional float cell_density = 1;
    optional float angle_offset = 2;
}


